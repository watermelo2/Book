指数值计算: 指数偏移值为2^(e−1)-1  e为指数的位数(该公式为规范规定). 
so:
单精度: 127
  无符号: 0~255
  指数真值: -127~128 

双精度: 1023
  无符号: 0~2407
  指数真值: -1023~1024

双头双尾(指数全为0或全为1)会被保留,有特殊用处.
单精度:
  去头尾: -126~127

双精度:
  去头尾: -1022~1023

浮点数规范化表示的数值为: (-1)^s * (1.f) * 2(指数值-指数偏移值)
S: 符号位.
M: 尾数部分. 尾数部分前隐含一个小数点,小鼠点前隐含一个1(注意噢!这个1不是数字1,而是二进制里的1).
E: 指数值-指数偏移值.

规范化形式推算: 符号位(sign) + 指数部分(exponent) + 尾数部分(fraction)
  单精度: 1 + 8 + 23 = 32

  双精度: 1 + 11 + 52 = 64

尾数部分计算公式
等比求和: Sn = a1 + a2 + a3 + .... + an
   q！=1 -> Sn = a1 * (1-q^n) / (1-q) 
   q ==1 -> Sn = n * a1    

1.f = 1.1111(n个1)
公比 q=0.5,a1=2^0
代入公式: 1.f = 2-2^(n-1)

单精度区间计算
最大: (-1)^0 * 1.1111..(23个1) * 2^127 
	= (2-2^-23) * 2^127
正数最小: (-1)^0 * 1.0 * 2^-126    
	= 2^-126


双精度区间计算
最大: (-1)^0 * 1.1111..(52个1) * 2^1023 
    = (2-2^-52) * 2^1023

正数最小: (-1)^0 * 1.0 * 2^-1022   
    = 2^-1022

问题: 对于单精度1.001 * 2^−125和1.01 * 2^−125,它们的差值是0.001 * 2^−125=1.0 * 2^−128
两个数值之间的差小于能够表示的最小值也就意味着两个不相等的数进行减法运算,将会瞬间下溢, 得到的结果将会是0,其实这就是精度不够的问题.

非标准化形式就这么诞生了: 利用之前的特殊指数位,如果指数部分全部为0,那么这就是一个非标准化形式.

非标准化
在非标准化情况下,尾数部分之前有隐含的小数点,但是小数点之前,隐含的不在是1而是0.
对于指数的真值,不再是指数部分表示的无符号数减掉指数偏移量一旦指数部分为0(也就是所有的比特位都是0),这就是一个标记符号了,不再有指数大小的含义.

这种情况下指数的真值为1-指数偏移量:
单精度: 1-127=-126
双精度: 1-1023=-1022

取值范围
最小值:
  单精度: 0.000...1(23位,最后一位为1) * 2^-126 = 2^-23 * 2^-126 = 2^-149 

  双精度: 0.000...1(52位,最后一位为1) * 2^-1022 = 2^-52 * 2^-1022 = 2^-1074

结论: 非标准化情况下尾数位更加精确了.


特殊值
无穷大: 指数部分中所有的bit的值全是1,f中所有bit的值全是0. 再加上符号位来区分正负.
NaN(Not a Number): 指数部分中所有bit的值全是1,f中所有bit的值不全是0.
0: 指数是0并且小数部分是0. 再加上符号位来区分正负.


