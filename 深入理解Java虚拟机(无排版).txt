线程隔离: 
	程序计数器: 当前线程所执行的字节码的行号指示器.


线程共享:	




内存分配几种方式



运行时数据区
线程私有
1.程序计数器: 当前线程所执行的字节码的行号指示器(记录下一条指令).
2.虚拟机栈: Java方法执行的内存模型. 每个方法在执行的同时都会创建一个栈帧用于存放局部变量表、操作数栈、动态链接、方法
		     出口等信息. 每个方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程. 
      说明: 在Java虚拟机规范中,对这个区域规定了两种异常情况: 如果线程请求的栈深入大于虚拟机所允许的深度,将抛出Stac
      		  kOverflowError异常; 如果虚拟机栈可以动态扩展但扩展时无法申请到足够的内存,就会抛出OutOfMemoryError
      		  异常.  Java虚拟机规范中允许固定长度的虚拟机栈,可以通过-Xss(-XX:ThreadStackSize)设置
3.本地方法栈: 与虚拟机发挥的作用是非常相似的,区别只不过它负责服务Native方法. 由于虚拟机规范中并没有对该区域强制规定
			    ,因此HotSpot VM直接将它们两个合二为一,所以执行Native方法也会抛出虚拟机栈一样的异常.

线程共享
1.Java堆(Heap): 存放对象实例. 虚拟机规范中描述--所有的对象实例以及数组都要在堆上分配,但是随着JIT编译器的发展与逃逸
				  分析技术逐渐成熟,栈上分配、标量替换优化技术将会导致一些微妙的变化发生.
2.方法区(Methord Area): 存储已被虚拟机加载的类信息、常量、静态便令、即使编译器后的代码等数据. 
      说明: HotSpot已经将'永久代'去掉了,使用了Native Memory来实现方法区的规划,并且字符串常量池已从'永久代'中移出.
  2.1.运行时常量池:  方法区的一部分,用于存放编译期生成的各种字面量和符号引用. 
  		说明: 运行时常量池相对Class文件常量池的另外一个重要特征是具备动态性,Java语言并不要求常量一定只有编译期才能
  			    产生,这种可以在运行期间将新的常量放入常量池中的特点对于开发人员来说常见的就有String#intern().
其它
1.直接内存: 它不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域. JDK1.4新加入的NIO库中,它可以使
			 用Native函数直接分配堆外内存,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行
			 操作,这样能够避免在Java堆和Native堆中来回复制数据. 这部分的内存并不由虚拟机内存控制且由
			 -XX:MaxDirectMemorySize设置大小.

对象存储时字段分配顺序.(CompactFields)

Java语言中可作为GC Roots的对象:
1.虚拟机栈(栈帧中的本地变量表)中引用的对象.
2.方法区中类静态属性引用的对象.
3.方法区中常量引用的对象.
4.本地方法栈中JNI引用的对象.

"无用类":
1. 该类所有的实例都已经被回收,也就是Java堆中不存在该类的任何实例.
2. 加载该类的ClassLoader已经被回收.
3. 该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法.


OSGI技术

频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能,以保证永久代不会溢出.

P69 重新看一遍
标记--清除算法
复制算法--确保连续内存空间(适合新生代这种'朝生夕死'这种情况,但会浪费一定的空间. 不理解的是为什么要两个Survivor) 
  		说明: [为什么有两个Survivor](https://codeahoy.com/2017/08/06/basics-of-java-garbage-collection/)
标记--整理算法
分代收集算法

Safe RegionGC时机问题


收集器
Young:
Serial(阻塞式GC)
ParNew(并行Serial)
Parallel Scavenge(吞吐量优先)

Tenured:
Serial Old(Serial老年代版本,'标记--整理'算法)
Parallel Old(Parallel Scavenge老年代版本,'标记--整理'算法)
CMS(Concurrent Mark Sweep)
G1(Garbage First)


GC日志
DefNew(Default New Generation): Serial收集器中的新生代
ParNew(Parallel New Generation): Parallel收集器中的新生代
PSYoungGen(Parallel Scavenge Young Generation): Parallel Scavenge收集器中的新生代 
Tenured: 老年代
Perm: 永久代

xxK->xxK(xxK): GC前该内存区域已使用容量-->GC后该内存区域已使用容量(该内存区域总容量)
[PSYoungGen: 1430K->0K(76288K)]: Parallel Scavenge收集器中的新生代GC前容量为1430K,GC后已使用OK,该内存区域总容量为76288K.

[Times: user=0.06 sys=0.00, real=0.01 secs]
单位: 秒
user: 用户态消耗的CPU时间
sys: 内核态消耗的CPU时间
real: 操作从开始到结束所经过的墙钟时间(Wall Clock Time)
CPU时间与墙钟时间的区别: 墙种时间包括各种非运算的等待耗时,例如等待磁盘I/O、等待线程阻塞,而CPU时间不
  包括这些耗时,但当系统有多CPU或者多核的话,多线程操作会叠加这些CPU(墙钟)时间.

动态对象年龄判断: 指如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半,年龄大于或等于的对象
   就可以直接进入老年代,无须等到MaxTenuringThreshold参数要求的年龄(默认15岁).

空间分配担保(P119 这个常听): 发生Minor GC之前,虚拟机会先检查老年代最大可用的连续空间是否大于新生代空间. 不成立则
   根据HandlerPromotionFailure参数来判断是否允许担保失败.不允许则Full GC来腾空间; 允许,那么继续检查老年代最大可
   用的连续空间是否大于历次机晋升到老年代对象的平均大小,如果大于则尝试进行Minor GC,否则Full GC(看的出来这些都是在
   做试探操作).
   注意: JDK6 Update24之后这个参数不成效了,规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小
      就会Minor GC,否则Full GC(我猜他们是认为没人会傻到让自己的JVM明明可以Minor GC却非要Full GC吧).

jstate
GC结果含义
 S0C: 年轻代中第一个survivor区的容量
 S1C: 年轻代中第二个survivor区的容量
 SOU: 年轻代中第一个survivor区目前已使用空间
 S1U: 年轻代中第二个survivor区目前已使用空间
  EC: 年轻代中Eden的容量
  EU: 年轻代中Eden目前已使用空间
  OC: Old代的容量
  OU: Old代目前已使用空间
  MC: 方法区大小
  MU: 方法区使用大小
CCSC: 压缩类空间大小
CCSU: 压缩类空间使用大小
 YGC: 从应用程序启动到采样时年轻代中gc次数
TGCT: 从应用程序启动到采样时年轻代中gc所用时间(s)
 FGC: 从应用程序启动到采样时old代(全gc)gc次数
FGCT: 从应用程序启动到采样时old代(全gc)gc所用时间(s)
 GCT: 从应用程序启动到采样时gc用的总时间(s)

LGCC(Last GC Cause): 最后一次GC原因


HotSwap技术(动态加入代码)
	BTrace工具

怎样手动触发full gc

Direct Memory在老年代满了后Full GC时才会发生回收. 

除Java堆和永久代外耗内存较多的区域,这里所有的内存总和受到操作系统进程最大内存的限制:
Direct Memory: 通过-XX:MaxDirectMemorySize调整大小.
线程堆栈: 通过-Xss调整大小. 内存不足抛出StackOverflowError(无法分配新的栈帧),或者
  OOM: unable to create new native thread(无法建立新的线程).
Socket缓存区: 每个Socket连接都有Receive和Send两个缓存区,分别占大约37KB和25KB内存,连接多的话这块占用
  也比较可观. 如果无法分配则可能抛出IOException: Too many open files.
JNI(Java Native Interface)代码: 本地库使用的内存也不在堆中.
虚拟机和GC: 虚拟机、GC的代码执行也要消耗一定的内存.


-XX:+DisableExplicitGC


Class文件用伪结构存储数据,伪结构中只有两种数据类型: 无符号数和表.
无符号数: 基本数据类型,u1、u2、u4、u8代表n个字节的无符号数,可以用来描述数字、索引引用、数量值、按照UTF-8编码
  构成字符串值.
表: 多个无符号数或其它表作为数据项构成的符合数据类型,所有表都习惯性地以'_info'结尾,用于描述有层级关系的复合
  结构的数据,整个Class文件本质上就是一张表,由[附件](Class文件格式)所示的数据项构成.


常量池主要存放两大类常量: 字面量(Literal)和符号引用(Symbolic References).
字面量: 文本字符串、声明为final的常量值等.

符号引用--这里涉及到一些编译原理方面的概念,概括了三类常量: 类和接口的全限定名(Fully Qualified Name)、字段
  的名称和描述符(Descriptor)、方法的名称和描述符.
说明: 在Class文件中不会保存各个方法、字段的最终内存布局信息,也就无法直接被虚拟机使用. 当虚拟机运行时,需要从
  常量池获得对应的符号引用,再在类创建时或运行时解析、翻译到具体的内存地址中(后面会说到).

'简单名称'、'描述符'、'全限定名'代表(虽然觉得没有太大记到这里的必要,但还是说明下吧):
简单名称: 没有类型和参数修饰的方法或者字段名称,TestClass类种的inc()方法和m字段的简单名称分别时'inc'和'm'.
描述符: 描述字段的数据类型、方法的参数列表(包括数量、类型以及顺序)和返回值.根据描述符规则,基本数据类型(byte、char、
  double、float、int、long、short、boolean)以及代表无返回值的void类型都用一个大写字符来表示,对象类型则用字符L加对
  象的全限定名类表示. 其它规则看《深入理解Java虚拟机(第二版)》P177
全限定名: com/daxigua/TestClass是这个com.daxigua.TestClass类的全限类名,就是把'.'换成了'/',为了使连续的多个
  全限定名之间不产生混淆,在使用时最后一般会加入一个';'表示全限定名结束.


ConstantValue属性: 通知虚拟机自动为静态变量赋值(注意: 这里只是静态变量,没有要求必须设置ACC_FINAL标志).  如果同时
  使用final和static来修饰一个变量并且这个变量的数据类型时基本类型或者java.lang.String的话,就生成ConstantValue属性
  来进行初始化,否则会选择在<clinit>()方法种进行初始化. 

StackMapTable属性: 用于类型检查验证器. 《Java虚拟机规范(Java SE7版)》中由详细描述.

字节码指令集可以分为9大类(《Java虚拟机规范(Java SE7版)》第6章中由详细描述): 
1.加载和存储指令:
Ⅰ: 将一个局部变量加载到操作数栈(load).
Ⅱ: 将一个数值从操作数栈存储到局部变量表(store).
Ⅲ: 将一个常量加载到操作数栈(push、ldc、const).
Ⅳ: 扩充局部变量表的访问索引的指令(wide).
补充: 类似于Tload_<n>这种,如:iload_0、iload_1都是某个带有一个操作数的通用指令,省略掉了显示的操作数. iload_0的语义
  与操作数为0时的iload指令语义一致.


2.运算指令--对两个操作数栈上的值进行某种特定运算,并把结果重新存入到操作数栈顶(原文为'操作栈顶',觉得是少打字了):  
加法: add
减法: sub
乘法: mul
除法: div
求余: rem
取反: neg
位移: shl、shr
比较: cmp、cmpg、cmpl
按位或: or
按位与: and
按位异或: xor
局部变量自增: iinc


3.类型转换指令--处理用户代码中的显示类型转换或者字节码指令集中数据类型相关指令无法与数据类型一一对应的问题:
Ⅰ: 窄化类型转换时需要靠指令完成: i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f. 窄化类型转换可能会出现各种问题
  ,如符号不同、数量级不同、精度丢失.例如将int或long类型窄化转换位整数类型T的时候,转换过程仅仅时简单地丢弃除最
  低位N个字节以外的内容,N是类型T的数类型长度,这可能导致转换结果与输入值有不同的正负号.
Ⅱ: 浮点值窄化位整数类型T(int或long类型之一)时遵循以下转换规则:
    ·: 如果浮点值时NaN,转换结果为0.
   ··: 如果浮点值不是无穷大的化,浮点值使用IEEE 754的向零舍入模式取整,获得整数值v,如果v在目标类型T的表示范围之内,
         那转换结果就是v,否则将根据v的符号转换为T所能表示的最大或最小正数.
Ⅲ: double类型窄化到float类型过程与IEEE 754中定义一致. 通过IEEE 754标准向最接近舍入模式得到一个可以使用float类型
      表示的数字. 如果转换结果的绝对值太大或者太小则返回float的正负零或正负无穷大. NaN值将转换为float的NaN值表示.
说明: 数据类型窄化会发生各种数值问题,但Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常.


4.对象创建与访问指令--虚拟机对类实例和数组的创建使用了不同的字节码指令:
创建类实例: new
创建数组: array
访问类字段和实例字段: field、static
把一个操作数栈的值存储到数组元素中: astore
取数组长度: arraylength
检查类实例类型: instaceof、checkcast

5.操作数栈管理指令:
将操作数栈顶一个或两个元素出栈: pop
复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶: dupN、dup_xN
将栈顶最顶端的两个数值互换(这个真的用的多吗): swap

6.控制转移指令:
条件分支: if;  这里列举几个典型的: ifeq、ifnull、if_icmpne
复合条件分支: tableswitch、lookupswitch
无条件分支: goto、jsr、ret

7.方法调用和返回指令:     
------------------------ 后面继续补充 ------------------------ 
invokevirtual: 调用对象的实例方法.
invokeinterface: 调用接口方法,它会在运行时搜索一个实现了这个接口方法的对象,找出适合的方法进行调用(指令会包含常量项
					CONSTANT_InterfaceMethodref_info).
invokespecial: 调用一些需要特殊处理的实例方法,包括实例初始化方法、私有方法、父类方法.
invokestatic: 调用类方法.
invokedynamic: 在运行时解析除调用点限定符所引用的方法,并执行该方法.

8.异常处理指令: 在Java程序中显示抛出异常的操作(throw)都由athrow指令实现. 
说明: 在Java虚拟机中,处理异常(catch)不是由字节码指令来实现的(曾经使用jsr和ret指令来实现),而是采用异常表来实现.

9.同步指令:
用于支持synchronized: monitorenter和monitorexit
说明: 字节码块级别的同步需要Javac编译器和Java虚拟机两者协作来支持,目的也就只有一个--方法中调用过的每条
	    monitorenter指令都必须执行其对应的monitorexit指令,无论这个方法是正常结束还是异常结束.具体实现为在同步代码
	    块开始处插入monitorenter,结束处插入monitorexit,并且编译器会自动产生一个异常处理器(方法表中的异常属
	    性,与Code同级)用来处理所有异常,而生成的异常代码块中就会加入monitorexit以及将异常对象入栈.
	    而方法级别的同步不需要指令控制. 虚拟机可以从方法表结构中的falgs中是否有ACC_SYNCHRONIZED访问标识来判断.
	    
JIT技术


类的生命周期: Loading--Verification--Preparation--Resolution--Initialization--Using--Unloading

5种情况必须进行类初始化:
1. 遇到new、getstatic、putstatic、invokestatic字节码指令时.
2. java.lang.reflect.
3. 子类初始化时父类也会初始化.
4. 启动时main方法所在的类.
5. 使用动态语言支持时,如果一个java.lang.invoke.MethodHandler实例最后的解析结果REF_getStatic、REF_putStatic、
     REF_invokeStatic的方法句柄,并且这个方法句柄所对应的类没有进行过初始化,则需要先触发其初始化.
说明: 接口与类的初始化区别在于第三种--接口在初始化时,并不要求其父接口全部都完成了初始化,只有在真正使用到父接口的时
        候(如引用接口中定义的常量)才会初始化.

方法体中Code属性的属性表中的StackMapTable属性: 利用该属性将之前字节码验证的类型推导方式转换为类型检查从而节省一些
  											   时间.

准备阶段: 正式为类变量分配内存并设置类变量初始值的阶段,这些变量所使用的内存都在方法区中进行分配. 
举例: 
  public static int val = 126;
在准备阶段时val的值为0而不是126,因为这个时候尚未开始执行任何Java方法,而把val赋值为126的putstatic指令是程序被编译后
  存放于类构造器<clinit>()方法之中.  
说明: boolean类型初始化默认为false,因为int默认值为0,多的就不解释了.


直接引用和符号引用的:
1. 符号引用明确规定在Java虚拟机规范的Class文件文件格式中,它与内存布局无关,所以各个虚拟机所接受的符号引用必须是一致
     的.
2. 直接引用可以是直接指向目标指针、相对偏移量或是一个能间接定位到目标的句柄,它就和虚拟机实现的内存布局相关的,如果有了
     直接引用,那引用的目标必定已经在内存中存在了.
说明: 符号引用相关的字节码指令有: anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、
							     invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、
							     multianewarray、new、putfield、putstatic
	    在执行这16个用于操作符号引用的字节码指令之前,先对它们所使用的符号引用进行解析.

JVM启动关闭字节码验证: -Xverify:none  
说明: 貌似在idea编辑器、需要1.3G左右内存的普通Spring Cloud GateWay模块中加入这个没有啥作用,感觉还慢了几秒.


Java虚拟机的解释执行引擎称为'基于栈的执行引擎',其中所指的'栈'就是操作数栈.

方法表(vtable)一般在类加载的连接阶段进行初始化,准备了类的变量初始值后,虚拟机会把该类的方法表也初始化完毕.
  除了这种用'方法表'来实现分派调用的'稳定优化'手段,还会使用内敛缓存(Inline Cache)和基于'类型继承关系分析'(Class 
  Hierarchy Analysis,CHA)技术的守护内联(Guarded Inlining)两种非稳定的'激进优化'手段来获得更高的性能.
说明: 内敛缓存和守护内敛在后面会说明.

动态语言特性: 它的类型检查的主体过程是在运行期而不是编译期. 换句话说它的变量无类型而变量值才有类型.

Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树再遍历语法树生成线性的字节码指令流的过程.

每一个JSP文件都对应一个Jsp类加载器

三类比较有代表性的编译器:
前端编译器: Sun--Javac、Eclipse JDT中的增量式编译器(ECJ).
JIT编译器: HotSpotVM的C1、C2编译器.
AOT编译器: GNU Complier for the Java(GCJ)、Excelsior JET.
说明: AOT编译器--静态提前编译器,直接把*.java文件编译成本地机器代码.					   

Javac编译过程:  .java-->解析与填充符号表-->注解处理-->分析与字节码生成-->.class
                     |___________________________|								     
                     		    周而复始
符号表(Symbol Table): 符号地址--符号信息(实际上符号表不一定是哈希表实现,可以是有序、树状、栈结构符号表等).   
说明: 

注解处理器(Annotation Processor): 可以在处理注解期间对语法树进行修改,编译器将回到解析及填充符号表的过程重新处理,
                                   知道所有插入式注解处理器都没有再对语法树进行修改为止,每一次循环称为一个Round.

解析与填充符号表: 将Java文件解析生成语法树、符号表. 默认构造函数在这里生成.

字节码生成: 将前面生成的信息(语法数、符号表)转化成字节码写到磁盘中,并且进行了少量的代码添加和转化工作. <init>()和
			 <clinit>()就是在这个阶段添加到语法树中的. 它会自动保证父类构造器(<init>())以及子类构造器的顺序执行
			 以及字段初始化,还有就是做些代码优化(把字符串的加操作替换为StringBuffer或StringBuilder的append等).

Signature(字节码层面的特征签名): 保存了参数化类型(泛型)的信息,方法和类中都可以有这个属性. 反射通过这个拿到的信息.
说明: 特征签名最终要的任务就是作为方法独一无二且不可重复的ID,在Java中的方法特征签名只包括了方法名称、参数顺序以及参
       数类型,而在字节码中的特征签名还包括方法返回值及受检查异常表. 重载、重写都会依据这个来实现.

编译器:
	Client Compiler: C1 
	Server Compiler: C2
解释器:
	Interperter
说明: 后续可能会碰到'逃生门'这个名词,它的作用是当激进性优化的假设不成立,如加载了新类后类型继承结构出现变化、出现'罕
       见陷阱'时可以通过逆优化退回到解释状态继续执行(当有解释器的虚拟机会让解释器配合,否则会采用不进行激进优化的
       C1编辑器担任'逃生门'的角色)	

-XX:CompileThreshold: 方法调用计数器阈值,Client模式默认1500,Server模式默认10000.
-XX:-UseCounterDecay: 启用、关闭热度衰减. 默认开启
-XX:CounterHalfLifeTime: 设置半衰周期的时间,单位秒
-XX:OnStackReplacePercentage: 设置回边计数器的阈值,它其实有两套公式(用于区分Client和Server模式)来计算的,在P335.
								Client、Server模式全默认情况下分别为13995和10700
-XX:-BackgroundComolation: 启用、禁止后台编译.禁止后一旦达到JIT编译条件,执行线程将会等到编译完成后再执行本地代码.								

晚期优化技术(运行期)
几项具有代表性的优化技术:
Ⅰ 语言无关的经典优化技术之一: 公共子表达式消除.
   例： int d = (cxb) x 12 + a + (a+bxc)
			  = (E) x 12 + a + (a+E)  // 公共子表达式消除
			  = E x 13 + a x   // 代数化简

Ⅱ 语言相关的经典优化技术之一: 数组范围检查消除.
   说明: 将运行期需要做的数组下标判断提前到编译期.

Ⅲ 最重要的优化技术之一: 方法内联.
   说明: 省去方法调用,为后续的其它优化做非常好的铺垫. 但由于Java提倡面向对象编程,所以方法内联会受到一定限制. 虚拟机
   	 	   虚拟机团队引入了'类型继承关系分析'(Class Hierarchy Analysis)的技术,当遇到真正的多态调用时采取激进化优
   	 	   化+逃生门(用于回到解释状态重新执行)


Ⅳ 最前沿的优化技术之一: 逃逸分析.
   说明: 该技术并不直接提供优化代码手段,而是为其它优化手段提供依据的分析技术. 
   定义: 逃逸分析的基本行为就是分析对象动态作用域--当一个对象在<?>中被定义后,它可能被外部<?>所引用,称为<?>逃逸(
   		   <?>: 可以是'方法'、'线程'等).
   对应优化(P355):
   栈上分配--将对象分配到栈上从而减轻GC压力.
   同步消除--将不会有线程的变量对应的同步措施消除.
   标量替换--拆分聚合量(Aggregate;具有代表性的就是对象)拆分为变量(Scalar)给需要访问的程序直接使用,可以认为将方法中
   			  获取对象属性的操作直接替换为访问栈上数据,这样除了可以让对象的成员变量在栈上分配和读写之外,还可以为后
   			  续进一步的优化手段创建条件.
    JVM参数: 开启逃逸分析-- -XX:+DoEscapeAnalysis 查看分析结果-- -XX:+PrintEscapeAnalysis 
    		 开启标量替换-- -XX:+EliminateAllocations 开启同步消除-- -XX:EliminateLocks
    		 查看标量的替换情况-- -XX:+PrintEliminateAllocation 


JMM下的一些'天然的'先行发生关系,这些关系无需任何同步器协调就存在并且可以直接使用. 但是,如果两个操作之间的关系不在此
  列并且无法从下列规则推导出来的话,它们就没有顺序性保障,虚拟机可以对它们随意地进行重排序.
注: 每条规则需要注意的前置因素或者的点我都标上了''号. 
程序次序规则(Program Order Rule): 在'一个线程'内,按照程序代码顺序,书写在前面的操作先行发生于书写在后面的操作. 准
								   确地说,应该是控制流顺序而不是程序代码顺序,因为要考虑分支、循环等结构.
管程锁定规则(Monitor Lock Rule): 一个unlock操作先行发生于后面对一个锁的lock操作这里必须强调的是'同一个锁'(而且需
								  要注意的是管程中的),而'后面'是值时间上的先后的先后顺序.
volatile变量规则(Volatile Variable Rule): 对'一个volatile变量'的写操作先行发生发生于后面对这个变量的读操作,这
										   里的'后面'同样是指时间上的先后顺序.
线程启动规则(Thread Start Rule): Thread对象的start()方法先行发生于此'线程的每一个动作'.
线程终止规则(Thread Termination Rule): 线程中的所有操作都先行发生于对此线程的'终止检测',我们可以通过Thread.join
										()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行(如果
									    Thread.isAlive()方法写在其它操作前呢?).
线程中断规则(Thread Interruption Rule): 对线程interrupt()方法的调用先行发生于被中断线程的代码'检测到中断事件的
									     发生',可以通过Thread.interrupted()方法检测到是否有中断发生.
对象终结规则(Finalizer Rule): 一个对象的'初始化完成'(构造函数执行结束)先行发生于它的finalize()方法的开始.
'传递'性(Transitivity): 如果操作A先行发生于操作B,操作B先行发生于操作C,那就可以得出操作A先行发生于操作C的结论.

举例:
volatile: 适用于不依赖原址场景. 如getter/setter的调用,因为'volatile变量规则'的保证. 


线程调度的两种方式: 协同式线程调度(Cooperative Threads-Scheduling) 和 抢占式线程调度(Preemptive Thread-Schedul
				    ing).
协同式线程调度: 线程的执行时间由线程本身来控制,线程把自己的工作执行完了之后,要主动通知系统切换到另外一个线程上. 协同
			     式多线程的最大好处是实现简单,而且由于线程要把自己的事情干完后才会进行线程切换,切换操作对线程自己是
			     可知的,所以没有什么线程同步问题. 弊端在于线程执行时间不可控,甚至如果一个线程编写有问题,一直不告诉
			     线程切换,那么程序就一直阻塞在那里.
         注释: 我可不可以这么认为--如果我能保证要执行的程序能够在任何时刻都能最终保证通知系统进行切换,那么携程就可
         	     以在编码和执行速度方面都更高效(因为不需要处理同步问题),甚至可以替代抢占式线程调度?  
         	   理由是它的弊端这么致命,但还是有这么多语言都纳入这个方案,那么它必然有特别明显大于抢占式线程调度的优
         	     点当在明知这个弊端的情况在.

抢占式线程调度: 每个线程将由线程来分配执行时间,线程的切换不由线程本身来决定(Thread.yield()可以让出调度,但线程本身
			     无法获取调度时间). 在这种实现线程调度的方式下,线程的执行时间是系统可控的,也不会有一个线程导致整个
			     进程阻塞的问题,Java使用的就是抢占式调度.

Java语言中各种操作共享的数据分为5类: 不可变(final)、绝对线程安全(组合操作安全)、相对线程安全(单个操作安全)、线程兼容(
								    加锁能控制)、线程对立(无药可救) 

'重量锁'的优化:
注: 该内容已经在很早之前学多线程的时候做了较详细的笔记,所以这里只是提提关键点以及之前没提到的点.
自旋锁与自适应锁: 等待线程并不会直接挂起到内核态而是先自旋,策略是根据前一次在同一个锁上的自旋时间及锁的拥有者的状态
				   决定的.
锁消除: 虚拟机发现并对被要求同步的代码但并不可能存在共享数据竞争的锁进行消除. 锁消除的主要判定依据来源于逃逸分析的数
		 据支持. 
	   那么为什么会存在把不需要同步的代码加上同步呢? 书上举的例子很好的证明了,下面看:
	   ```
	   public String concatString(String s1,String s2,String s3){
	   		return s1 + s2 + s3;
	   }
	   ```				 
	   经过Javac编译后会变成类似于这样的代码
	   ```
	   public String concatString(String s1,String s2,String s3){
	   	 	StringBuffer sb = new StringBuffer();
	   	 	sb.append(s1);
	   	 	sb.append(s2);
	   	 	sb.append(s3);
	   	 	return sb.toString();
	   }
	   ```
	   而StringBuffer是'相对线程安全'的类. 虚拟机发现sb对象不会'逃逸'到concatString()方法外,因此就会将同步块消除
	   .
锁粗化: 如果一系列的连续操作都对同一个对象反复的加锁解锁也会导致性能损耗,特殊场景下会选择直接粗化.
轻量锁: 在描述轻量锁前我想说我对那个HotSpot的MarkWord表格理解没到位...感觉有点不对称~
		  HotSpot虚拟机的对象头(Object Header)分为两部分信息,第一部分用于存储对象自身的运行时数据,如哈希码、GC分
		代年龄等,数据长度根据虚拟机多少位等价判断,官方称它为'Mark Word',它时实现轻量级和偏向锁的关键. 另外一部分用
		于存储指向方法区对象类型数据的指针,如果时数组对象的话,还会有一个额外的部分用于存储数组长度.
		  代码进入同步块时,如果此同步对象没有被锁定(锁标志位为'01'状态),虚拟机首先将在当前线程的栈帧中建立一个名为
		锁记录(Lock Record)的空间,用于存储锁对象目前的Mark Word的拷贝(官方把这份拷贝加了一个Displaced前缀,即Disp
		lace Mark Word). 然后虚拟机将使用CAS尝试将对象的Mark Word更新为指向Lock Record的指针.更新成功则当前线程
		拥有了该对象的锁,并且对象的Mark Word的锁标志位(Mark Word的最后2bit)将转变为'00'(轻量锁状态),参考图1.
		更新失败则虚拟机检查对象Mark Work是否指向当前线程栈帧,如果只说明当前线程已经拥有了这个对象的锁,那就可以直接
		进入同步块继续执行,否则说明这个锁对象已经被其它线程抢占了. 如果有线程争用同一个锁,那轻量级的锁就不再有效,要
		膨胀为重量级锁,锁标志的状态值为'10',Mark Word中存储的就是指向重量级锁的指针,后面等待锁的线程也要进入阻塞状
		态.
		  解锁过程也是CAS,如果对象的Mark Word仍然指向线程的锁记录,那就用CAS操作把对象当前的Mark Word和线程中复制
		的Displaced Mark Word替换回来,如果替换成功整个同步过程完成了.如果替换失败则说明有其它线程尝试过获取该锁,
		那就要在释放锁的同时唤醒被挂起的线程.

	    附件:
	    (参考图1)[D:\PersonalSpace\Study\Doc\other\书籍源码\深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）
	    源代码\file\轻量锁CAS操作后堆栈于对象的状态.png].	

	    说明: 不太明白的两个地方: 那张Mark Word表格和指向锁记录的指针是什么?它难道不就是一个标识吗?
偏向锁: 偏向单个线程的锁,乐观状态下连加锁动作都可以省略.

Code Cache: 这是块独立于java堆之外的内存区域,缓存编译后的代码. 包含jit编译的机器码以及java所使用的本地方法代码(JN
			  I). 如果满了则会输出类似于'CodeCade is full. Compiler has bean disabled.'的日志. jit优化将会停
			  止. 可以通过-XX:ReservedCodeCacheSize设置



问: Java8没有永久代,变成metaspace了?
答: [PerMgen-Removed](https://www.infoq.com/articles/Java-PERMGEN-Removed/) 
	、[What is the difference between PermGen and Metaspace?]
	(https://stackoverflow.com/questions/27131165/what-is-the-difference-between-permgen-and-metaspace)
	我认为区别在于主要因素是在于内存大小分配以及回收. 原因可能是因为PerMgen出生时还不存在JIT等技术,导致继在PerMgen上做调整的
	话可能会很麻烦.

问:这个-Xmx和-Xms配的到底是什么? old和eden、s0、s1啥关系. 
答:-Xmx和-Xms设置的是Heap的最大、最小值. GC的主要关注区域,当前商业虚拟机的垃圾收集都采用'分代收集'(Generational Collection)
     算法根据对象存活周期的不同将内存划分为几块,一般是把Java堆分为新生代和老年代,这样就可以根据各个年代的特点采用适合的收集算法
     . eden和old就分别代表了'新生代(年轻代)'和'老年代'两个区域. 新生代大部分情况下每次GC都只有少量对象存活,所以选择复制算法;
     而老年代因为对象存活率高,所以使用'标记-清理'或者'标记-整理'算法进行回收. 
  在新生代复制算法中,包含两个特殊的区域称为s0、s1(全称Survivor0、Survivor1),分别作为实现复制算法的一份子.  


